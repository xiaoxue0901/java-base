# 1、线程基础、线程之间的共享和协作
## 基础概念
- CUP核心数和线程数的关系
    > 比例,1:1, 例如: 8核CPU可以有8个线程
     超线程技术: 比例,1:2             
     实际中, 感觉线程数超过了核心数, 原因看CPU时间片轮转机制
                  
- CPU时间片轮转机制
> 古老,简单的算法, 又称为RR调度: 给一个进程分配一个时间段.上下文切换. 
> 开发用处: 每个线程分配时间比例, 避免出现上下文切换时间耗时过多, 效率减慢.

- 什么是进程和线程
> 进程: 程序运行进行资源分配的最小单位,独立的,进程内部可以有多个线程, 多个线程之间会共享进程资源. 进程与进程之间相互独立.
> 线程: CPU调度的最小单位,线程必须依附于进程运行, 线程本身是不拥有系统资源, 进程启动后, 进程的资源分配给线程用.

- 并行和并发
> 并行: 同一时刻,可以处理事情的能力.(任务同时执行)
> 并发: 与时间单位相关, 在单位时间段内, 处理事情的能力.(任务交替执行)

- 高并发编程的意义、好处
> 1. 充分利用CPU的资源.
> 2. 加快程序响应速度
> 3. 代码模块化,异步化处理

- 高并发编程注意事项
> 共享资源,存在冲突.
> 多线程之间的死锁问题
> 线程数太多, 资源消耗多,就有可能耗尽系统资源, 内存耗尽

## 认识java中的线程
- Java里程序天生就是多线程的,那么有几种新启动线程的方式? 
> 类Thread
> 接口Runnable
> 接口Callable
- 有开始就有结束, 怎么样才能让Java里的线程安全停止工作呢?
> stop/interrupt(), isInterrupted, static方法interrupted
线程终止
>1. 自然执行完;2. 抛出异常
* 废弃的中断线程的方法.
> stop():强行终止线程,线程的资源未正确释放, 会导致其他线程未知问题(不建议用)
> resume(): 废弃方法.
> suspend():调用后线程不释放资源.容易引起死锁 (不建议用)
- 相对安全的中止线程方法
`java线程是协作式, 调用下列方法时`
>interrupt(): 中断一个线程,不是强制关闭, 而是打个招呼, 将中断标志位设置为true
>isInterrupted(): 判定当前线程是否处于中断状态, 查看中断标志位
> static 的interrupted(): 判定当前线程是否处于中断状态, 将中断标志位改为false.
> 方法抛出InterruptedException: 线程的中断标志位会被复位成false, 需要在catch中再次调用interrupt()

## 线程的生命周期 (1.41分)
- 线程常用方法和线程的状态
    * 深入理解run和start
    * 了解yield(): 将线程从运行状态转到可运行状态
    * 线程状态: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED
- 线程的优先级
    * 范围:1-10, 默认5. 最大10, 最小1
    * 在不同的操作系统下, 不同的反应, 有的操作系统会忽略此设置.
- 守护线程 
    * 和主线程共死.
    * 守护线程中的try..finally不一定执行.

## 什么是线程间的共享?
- synchronized内置锁
    * 用处: 代码块, 方法
    * 对象锁
    * 类锁
- volatile关键字, 最轻量的同步机制
    * 保证可见性, 不保证原子性
    * 用在变量上
- ThreadLocal的使用.
    * 可确保每个线程只使用自己的那部分.
    * 每个线程拥有自己的副本. 适用于数据小的应用
    * 用空间换取安全.

## 什么是线程中的协作?
- 等待和通知
    * wait()
    * notify()/notifyAll()
    * 等待和通知的标准范式
        等待方
        1. 获取对象的锁
        2. 循环里判断条件是否满足,不满足用wait()方法.
        3. 条件满足, 执行业务逻辑
        通知方
        1. 获得对象的锁.
        2. 改变条件,
        3. 通知所有等待在对象上的线程.    
    * notify()和notifyAll()应该用谁?
        1. 建议notifyAll(), 可能发生信号丢失的情况
    * 等待超时模式实现一个连接池
        1. 假设等待时长为T, 当前时间now()+T后超时.
        
        3. long remain = T// 等待的持续时间
        4. while(result不满足条件 && remain>0){wait(remain); remain = overtime-now} return result;
    * 写了DBPool    
- join(): 主线程等待指定的线程终止, 再继续下一步的操作.让多线程的执行串行化.
```java
// 使用方式
        log.info("我是主线程");
        a.start();
        a.join();
        b.start();
        b.join();
        log.info("我是主线程end");
```
问: 有线程A和线程B, 如何保证线程B执行完毕后执行线程A?
    * 方法1: 线程A, 执行了线程B的join方法, 线程A必须等待线程B执行完毕之后, 线程A才能继续自己的工作.
    * 方法2: 使用CountDownLatch 

调用yield(), sleep(), wait(), notify()等方法对锁有何影响?
- yield(): 线程在执行yield后, 线程持有的锁不释放的.
- sleep(): 线程在执行sleep()后, 线程持有的锁不释放.
- wait(): 调用wait()前, 必须要持有锁, 线程在执行wait()后, 线程持有的锁会被释放(虚拟机自动处理).当wait()返回时, 当前wait()线程会重新持有锁(虚拟机保证).
- notify(): 线程在执行notify()后, 线程持有的锁不释放. 直到notify()所在的方法全部执行完毕后, 才会释放锁. 


问: 
1. Java的内存模型? 
2. LinkedList的用法?
3. 调用yield(), sleep(), wait(), notify()等方法对锁有何影响?
4. join()方法.





