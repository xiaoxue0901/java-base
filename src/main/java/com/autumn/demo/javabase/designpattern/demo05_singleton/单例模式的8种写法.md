<h1>单例模式的8种写法</h1>
---
参考地址: [单例模式的八种写法比较](https://www.cnblogs.com/zhaoyan001/p/6365064.html) 


单例模式的实现思路   
* Singleton类只会生成一个实例. 该类定义了static字段(类的成员变量), 并将其初始化为Singleton类的实例.初始化行为仅
在该类被加载时进行一次.
* Singleton类的构造函数是private的, 为了禁止从Singleton类外部调用构造函数.

**总结:** 
> 1. 定义private static Singleton INSTANCE;的成员变量; 
> 2. 构造函数私有.

写法一: 饿汉式(静态常量)[可用]
优点：这种写法比较简单，就是在类装载的时候就完成实例化。避免了线程同步问题。

缺点：在类装载的时候就完成实例化，没有达到Lazy Loading的效果。如果从始至终从未使用过这个实例，则会造成内存的浪费。

写法二: 饿汉式(静态代码块)[可用]
将类实例化的过程放在了静态代码块中，也是在类装载的时候，就执行静态代码块中的代码，初始化类的实例。优缺点和上面是一样的。

写法三: 懒汉式(线程不安全)[不可用]
这种写法起到了Lazy Loading的效果，但是只能在单线程下使用。如果在多线程下，一个线程进入了if (singleton == null)判断语句块，还未来得及往下执行，另一个线程也通过了这个判断语句，这时便会产生多个实例。所以在多线程环境下不可使用这种方式。

写法四: 懒汉式(线程安全, synchronize同步方法)[效率低]
优点: 解决了线程不安全的问题.
缺点: 同步效率低.

写法五: 懒汉式(线程安全, 同步代码块)[不推荐]
要么效率低, 要么不安全

写法六: DCL(双重检查锁机制 Double Check Lock) [推荐用]

写法七: 静态内部类[推荐用]
这种方式跟饿汉式方式采用的机制类似，但又有不同。两者都是采用了类装载的机制来保证初始化实例时只有一个线程。不同的地方在饿汉式方式是只要Singleton类被装载就会实例化，没有Lazy-Loading的作用，而静态内部类方式在Singleton类被装载时并不会立即实例化，而是在需要实例化时，调用getInstance方法，才会装载SingletonInstance类，从而完成Singleton的实例化。

类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。

写法八: 用枚举实现单例模式[推荐用]

总结: 使用写法一,二,六,七,八. 以后用写法八或写法七.




